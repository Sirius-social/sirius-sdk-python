<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite errors="0" failures="3" hostname="MacBook-Pro-Valentin.local" name="pytest" skipped="0" tests="12" time="393.231" timestamp="2022-02-20T14:50:52.723171"><testcase classname="test_wallet" file="test_wallet.py" line="9" name="test_crypto_pack_message" time="48.446"></testcase><testcase classname="test_wallet" file="test_wallet.py" line="35" name="test_crypto_sign" time="0.381"></testcase><testcase classname="test_wallet" file="test_wallet.py" line="58" name="test_did_maintenance" time="0.511"></testcase><testcase classname="test_wallet" file="test_wallet.py" line="97" name="test_their_did_maintenance" time="33.101"></testcase><testcase classname="test_wallet" file="test_wallet.py" line="130" name="test_record_value" time="31.427"></testcase><testcase classname="test_wallet" file="test_wallet.py" line="155" name="test_record_value_with_tags" time="34.179"></testcase><testcase classname="test_wallet" file="test_wallet.py" line="192" name="test_record_value_with_tags_then_update" time="33.745"></testcase><testcase classname="test_wallet" file="test_wallet.py" line="226" name="test_record_search" time="8.749"><failure message="aiohttp.client_exceptions.WSServerHandshakeError: 403, message=&apos;Invalid response status&apos;, url=URL(&apos;http://localhost/rpc&apos;)">agent1 = &lt;sirius_sdk.agent.agent.Agent object at 0x7fe41b4a7ca0&gt;

    @pytest.mark.asyncio
    async def test_record_search(agent1: Agent):
&gt;       await agent1.open()

test_wallet.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../sirius_sdk/agent/agent.py:233: in open
    self.__rpc = await AgentRPC.create(
../sirius_sdk/agent/connections.py:96: in create
    await instance._connector.open()
../sirius_sdk/base.py:108: in open
    self._ws = await self.__session.ws_connect(url=self._url, ssl=False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;aiohttp.client.ClientSession object at 0x7fe41b615a30&gt;, url = &apos;http://localhost/rpc&apos;

    async def _ws_connect(
        self,
        url: StrOrURL,
        *,
        method: str = hdrs.METH_GET,
        protocols: Iterable[str] = (),
        timeout: float = 10.0,
        receive_timeout: Optional[float] = None,
        autoclose: bool = True,
        autoping: bool = True,
        heartbeat: Optional[float] = None,
        auth: Optional[BasicAuth] = None,
        origin: Optional[str] = None,
        params: Optional[Mapping[str, str]] = None,
        headers: Optional[LooseHeaders] = None,
        proxy: Optional[StrOrURL] = None,
        proxy_auth: Optional[BasicAuth] = None,
        ssl: Union[SSLContext, bool, None, Fingerprint] = None,
        verify_ssl: Optional[bool] = None,
        fingerprint: Optional[bytes] = None,
        ssl_context: Optional[SSLContext] = None,
        proxy_headers: Optional[LooseHeaders] = None,
        compress: int = 0,
        max_msg_size: int = 4 * 1024 * 1024,
    ) -&gt; ClientWebSocketResponse:
    
        if headers is None:
            real_headers = CIMultiDict()  # type: CIMultiDict[str]
        else:
            real_headers = CIMultiDict(headers)
    
        default_headers = {
            hdrs.UPGRADE: &quot;websocket&quot;,
            hdrs.CONNECTION: &quot;upgrade&quot;,
            hdrs.SEC_WEBSOCKET_VERSION: &quot;13&quot;,
        }
    
        for key, value in default_headers.items():
            real_headers.setdefault(key, value)
    
        sec_key = base64.b64encode(os.urandom(16))
        real_headers[hdrs.SEC_WEBSOCKET_KEY] = sec_key.decode()
    
        if protocols:
            real_headers[hdrs.SEC_WEBSOCKET_PROTOCOL] = &quot;,&quot;.join(protocols)
        if origin is not None:
            real_headers[hdrs.ORIGIN] = origin
        if compress:
            extstr = ws_ext_gen(compress=compress)
            real_headers[hdrs.SEC_WEBSOCKET_EXTENSIONS] = extstr
    
        ssl = _merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)
    
        # send request
        resp = await self.request(
            method,
            url,
            params=params,
            headers=real_headers,
            read_until_eof=False,
            auth=auth,
            proxy=proxy,
            proxy_auth=proxy_auth,
            ssl=ssl,
            proxy_headers=proxy_headers,
        )
    
        try:
            # check handshake
            if resp.status != 101:
&gt;               raise WSServerHandshakeError(
                    resp.request_info,
                    resp.history,
                    message=&quot;Invalid response status&quot;,
                    status=resp.status,
                    headers=resp.headers,
                )
E               aiohttp.client_exceptions.WSServerHandshakeError: 403, message=&apos;Invalid response status&apos;, url=URL(&apos;http://localhost/rpc&apos;)

/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/aiohttp/client.py:792: WSServerHandshakeError</failure></testcase><testcase classname="test_wallet" file="test_wallet.py" line="278" name="test_register_schema_in_network" time="54.637"></testcase><testcase classname="test_wallet" file="test_wallet.py" line="295" name="test_register_cred_def_in_network" time="117.900"></testcase><testcase classname="test_wallet" file="test_wallet.py" line="321" name="test_nym_operations_in_network" time="21.952"><failure message="aiohttp.client_exceptions.WSServerHandshakeError: 502, message=&apos;Invalid response status&apos;, url=URL(&apos;http://localhost/rpc&apos;)">agent1 = &lt;sirius_sdk.agent.agent.Agent object at 0x7fe41b70a6d0&gt;, agent2 = &lt;sirius_sdk.agent.agent.Agent object at 0x7fe41b70a220&gt;, default_network = &apos;default&apos;

    @pytest.mark.asyncio
    async def test_nym_operations_in_network(agent1: Agent, agent2: Agent, default_network: str):
        await agent1.open()
&gt;       await agent2.open()

test_wallet.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../sirius_sdk/agent/agent.py:233: in open
    self.__rpc = await AgentRPC.create(
../sirius_sdk/agent/connections.py:96: in create
    await instance._connector.open()
../sirius_sdk/base.py:108: in open
    self._ws = await self.__session.ws_connect(url=self._url, ssl=False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;aiohttp.client.ClientSession object at 0x7fe41b70a8b0&gt;, url = &apos;http://localhost/rpc&apos;

    async def _ws_connect(
        self,
        url: StrOrURL,
        *,
        method: str = hdrs.METH_GET,
        protocols: Iterable[str] = (),
        timeout: float = 10.0,
        receive_timeout: Optional[float] = None,
        autoclose: bool = True,
        autoping: bool = True,
        heartbeat: Optional[float] = None,
        auth: Optional[BasicAuth] = None,
        origin: Optional[str] = None,
        params: Optional[Mapping[str, str]] = None,
        headers: Optional[LooseHeaders] = None,
        proxy: Optional[StrOrURL] = None,
        proxy_auth: Optional[BasicAuth] = None,
        ssl: Union[SSLContext, bool, None, Fingerprint] = None,
        verify_ssl: Optional[bool] = None,
        fingerprint: Optional[bytes] = None,
        ssl_context: Optional[SSLContext] = None,
        proxy_headers: Optional[LooseHeaders] = None,
        compress: int = 0,
        max_msg_size: int = 4 * 1024 * 1024,
    ) -&gt; ClientWebSocketResponse:
    
        if headers is None:
            real_headers = CIMultiDict()  # type: CIMultiDict[str]
        else:
            real_headers = CIMultiDict(headers)
    
        default_headers = {
            hdrs.UPGRADE: &quot;websocket&quot;,
            hdrs.CONNECTION: &quot;upgrade&quot;,
            hdrs.SEC_WEBSOCKET_VERSION: &quot;13&quot;,
        }
    
        for key, value in default_headers.items():
            real_headers.setdefault(key, value)
    
        sec_key = base64.b64encode(os.urandom(16))
        real_headers[hdrs.SEC_WEBSOCKET_KEY] = sec_key.decode()
    
        if protocols:
            real_headers[hdrs.SEC_WEBSOCKET_PROTOCOL] = &quot;,&quot;.join(protocols)
        if origin is not None:
            real_headers[hdrs.ORIGIN] = origin
        if compress:
            extstr = ws_ext_gen(compress=compress)
            real_headers[hdrs.SEC_WEBSOCKET_EXTENSIONS] = extstr
    
        ssl = _merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)
    
        # send request
        resp = await self.request(
            method,
            url,
            params=params,
            headers=real_headers,
            read_until_eof=False,
            auth=auth,
            proxy=proxy,
            proxy_auth=proxy_auth,
            ssl=ssl,
            proxy_headers=proxy_headers,
        )
    
        try:
            # check handshake
            if resp.status != 101:
&gt;               raise WSServerHandshakeError(
                    resp.request_info,
                    resp.history,
                    message=&quot;Invalid response status&quot;,
                    status=resp.status,
                    headers=resp.headers,
                )
E               aiohttp.client_exceptions.WSServerHandshakeError: 502, message=&apos;Invalid response status&apos;, url=URL(&apos;http://localhost/rpc&apos;)

/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/aiohttp/client.py:792: WSServerHandshakeError</failure></testcase><testcase classname="test_wallet" file="test_wallet.py" line="374" name="test_attribute_operations_in_network" time="7.876"><failure message="aiohttp.client_exceptions.WSServerHandshakeError: 502, message=&apos;Invalid response status&apos;, url=URL(&apos;http://localhost/rpc&apos;)">agent1 = &lt;sirius_sdk.agent.agent.Agent object at 0x7fe41b7e2e80&gt;, agent2 = &lt;sirius_sdk.agent.agent.Agent object at 0x7fe41b7e2be0&gt;, default_network = &apos;default&apos;

    @pytest.mark.asyncio
    async def test_attribute_operations_in_network(agent1: Agent, agent2: Agent, default_network: str):
&gt;       await agent1.open()

test_wallet.py:377: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../sirius_sdk/agent/agent.py:233: in open
    self.__rpc = await AgentRPC.create(
../sirius_sdk/agent/connections.py:96: in create
    await instance._connector.open()
../sirius_sdk/base.py:108: in open
    self._ws = await self.__session.ws_connect(url=self._url, ssl=False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;aiohttp.client.ClientSession object at 0x7fe41b7e2250&gt;, url = &apos;http://localhost/rpc&apos;

    async def _ws_connect(
        self,
        url: StrOrURL,
        *,
        method: str = hdrs.METH_GET,
        protocols: Iterable[str] = (),
        timeout: float = 10.0,
        receive_timeout: Optional[float] = None,
        autoclose: bool = True,
        autoping: bool = True,
        heartbeat: Optional[float] = None,
        auth: Optional[BasicAuth] = None,
        origin: Optional[str] = None,
        params: Optional[Mapping[str, str]] = None,
        headers: Optional[LooseHeaders] = None,
        proxy: Optional[StrOrURL] = None,
        proxy_auth: Optional[BasicAuth] = None,
        ssl: Union[SSLContext, bool, None, Fingerprint] = None,
        verify_ssl: Optional[bool] = None,
        fingerprint: Optional[bytes] = None,
        ssl_context: Optional[SSLContext] = None,
        proxy_headers: Optional[LooseHeaders] = None,
        compress: int = 0,
        max_msg_size: int = 4 * 1024 * 1024,
    ) -&gt; ClientWebSocketResponse:
    
        if headers is None:
            real_headers = CIMultiDict()  # type: CIMultiDict[str]
        else:
            real_headers = CIMultiDict(headers)
    
        default_headers = {
            hdrs.UPGRADE: &quot;websocket&quot;,
            hdrs.CONNECTION: &quot;upgrade&quot;,
            hdrs.SEC_WEBSOCKET_VERSION: &quot;13&quot;,
        }
    
        for key, value in default_headers.items():
            real_headers.setdefault(key, value)
    
        sec_key = base64.b64encode(os.urandom(16))
        real_headers[hdrs.SEC_WEBSOCKET_KEY] = sec_key.decode()
    
        if protocols:
            real_headers[hdrs.SEC_WEBSOCKET_PROTOCOL] = &quot;,&quot;.join(protocols)
        if origin is not None:
            real_headers[hdrs.ORIGIN] = origin
        if compress:
            extstr = ws_ext_gen(compress=compress)
            real_headers[hdrs.SEC_WEBSOCKET_EXTENSIONS] = extstr
    
        ssl = _merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)
    
        # send request
        resp = await self.request(
            method,
            url,
            params=params,
            headers=real_headers,
            read_until_eof=False,
            auth=auth,
            proxy=proxy,
            proxy_auth=proxy_auth,
            ssl=ssl,
            proxy_headers=proxy_headers,
        )
    
        try:
            # check handshake
            if resp.status != 101:
&gt;               raise WSServerHandshakeError(
                    resp.request_info,
                    resp.history,
                    message=&quot;Invalid response status&quot;,
                    status=resp.status,
                    headers=resp.headers,
                )
E               aiohttp.client_exceptions.WSServerHandshakeError: 502, message=&apos;Invalid response status&apos;, url=URL(&apos;http://localhost/rpc&apos;)

/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/aiohttp/client.py:792: WSServerHandshakeError</failure></testcase></testsuite></testsuites>